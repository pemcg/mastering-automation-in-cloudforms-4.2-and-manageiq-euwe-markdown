<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Ansible Tower Services</title>
<date>2016-12-10</date>
</info>
<section xml:id="ansible-tower-services">
<title>Ansible Tower Services</title>
<simpara>One of the available catalog item types when we create a new service item is <emphasis role="strong">AnsibleTower</emphasis> (see <xref linkend="i1"/>)</simpara>
<figure xml:id="i1">
<title>Ansible Tower catalog item type</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ss1.png" contentwidth="500" align="center"/>
</imageobject>
<textobject><phrase>Screenshot</phrase></textobject>
</mediaobject>
</figure>
<simpara>&#8203;<?asciidoc-br?></simpara>
<simpara>In this chapter we&#8217;ll investigate the Automate datastore components that allow us to create Ansible Tower services and service bundles that include Ansible Tower jobs.</simpara>
<section xml:id="_the_ansible_tower_service_provisioning_state_machine">
<title>The Ansible Tower Service Provisioning State Machine</title>
<simpara>The <emphasis>/ConfigurationManagement/AnsibleTower/Service/Provisioning</emphasis> namespace in the datastore contains the service provisioning state machines, methods and associated email classes that are required to provisioning services into Ansible Tower (see <xref linkend="i2"/>).</simpara>
<figure xml:id="i2">
<title>ConfigurationManagement/AnsibleTower namespace</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ss2.png" contentwidth="320" align="center"/>
</imageobject>
<textobject><phrase>Screenshot</phrase></textobject>
</mediaobject>
</figure>
<simpara>&#8203;<?asciidoc-br?></simpara>
<simpara>The two out-of-the-box instances of the <emphasis>Provision</emphasis> state machine are <emphasis>default</emphasis> and <emphasis>provision_from_bundle</emphasis>. We use <emphasis>default</emphasis> when we&#8217;re creating a single standalone service, and <emphasis>provision_from_bundle</emphasis> when we&#8217;re running an Ansible Tower job as part of a service bundle comprising both VM provisioning and Ansible configuration operations.</simpara>
<section xml:id="_the_default_state_machine_instance">
<title>The <emphasis>default</emphasis> State Machine Instance</title>
<simpara>The <emphasis>default</emphasis> state machine instance is called to process individual service catalog items. The fields of this state machine are shown in <xref linkend="i3"/>.</simpara>
<figure xml:id="i3">
<title>Fields of the default state machine</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ss3.png" contentwidth="800" align="center"/>
</imageobject>
<textobject><phrase>Screenshot</phrase></textobject>
</mediaobject>
</figure>
<simpara>&#8203;<?asciidoc-br?></simpara>
<section xml:id="_pre1">
<title>pre1</title>
<simpara>The <emphasis role="strong">pre1</emphasis> state calls the <emphasis>preprovision</emphasis> method, that checks whether the inputs are valid, and prints some of the input values to <emphasis>automation.log</emphasis>. It contains a useful method called <emphasis>modify_job_options</emphasis> that by default is not called (the call is commented out), but would allow us to customise any of the job options if we wished to clone and edit the method.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def modify_job_options(service)
  # Example how to programmatically modify job options:
  job_options = service.job_options
  job_options[:limit] = 'someHost'
  job_options[:extra_vars]['flavor'] = 'm1.small'

  # Important: set stack_options
  service.job_options = job_options
end</programlisting>
</section>
<section xml:id="_provision">
<title>provision</title>
<simpara>The <emphasis role="strong">provision</emphasis> state calls the <emphasis>provision</emphasis> method, which performs some preliminary checking before calling the service object&#8217;s <literal>launch_job</literal> method.</simpara>
</section>
<section xml:id="_checkprovisioned">
<title>checkprovisioned</title>
<simpara>The <emphasis role="strong">checkprovisioned</emphasis> state calls the <emphasis>check_provisioned</emphasis> method, which calls the service object&#8217;s <literal>job</literal> method to retrieve the ManageIQ_Providers_AnsibleTower_ConfigurationManager_Job object, and then calls the <literal>normalized_live_status</literal> job method to retrieve the current job status.</simpara>
</section>
<section xml:id="_post1">
<title>post1</title>
<simpara>The <emphasis role="strong">post1</emphasis> state calls the <emphasis>post_provisioned</emphasis> method which allows us to perform any optional post-processing that we might deem necessary. It contains a useful method called <emphasis>dump_job_outputs</emphasis> that by default is not called (the call is commented out), but would allow us to write the job output to <emphasis>automation.log</emphasis> if required.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def dump_job_outputs(job)
  log_type = job.status == 'failed' ? 'error' : 'info'
  @handle.log(log_type, "Ansible Tower Job #{job.name} standard output: #{job.raw_stdout}")
end</programlisting>
</section>
<section xml:id="_emailowner">
<title>EmailOwner</title>
<simpara>The <emphasis role="strong">EmailOwner</emphasis> state calls the <emphasis>ServiceProvision_complete</emphasis> email instance to notify the service requester that the service has completed.</simpara>
</section>
<section xml:id="_finished">
<title>Finished</title>
<simpara>The <emphasis role="strong">Finished</emphasis> state calls the <emphasis>/System/CommonMethods/StateMachineMethods/service_provision_finished</emphasis> instance to terminate the service provision state machine processing.</simpara>
</section>
</section>
<section xml:id="_the_provision_from_bundle_state_machine_instance">
<title>The <emphasis>provision_from_bundle</emphasis> State Machine Instance</title>
<simpara>The <emphasis>provision_from_bundle</emphasis> state machine instance is called when an Ansible service catalog item is to be called from a service bundle after a VM provisioning service catalog item. The fields of this state machine are shown in <xref linkend="i4"/>.</simpara>
<figure xml:id="i4">
<title>Fields of the provision_from_bundle state machine</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ss4.png" contentwidth="800" align="center"/>
</imageobject>
<textobject><phrase>Screenshot</phrase></textobject>
</mediaobject>
</figure>
<simpara>&#8203;<?asciidoc-br?></simpara>
<simpara>As can be seen, the difference between this state machine and <emphasis>default</emphasis> is that <emphasis>preprovision</emphasis> has moved to the <emphasis role="strong">pre2</emphasis> state, and there are new relationships in the <emphasis role="strong">sequencer</emphasis> and <emphasis role="strong">pre1</emphasis> states to call <emphasis>GroupSequenceCheck</emphasis> and <emphasis>CatalogItemInitialization</emphasis>.</simpara>
<section xml:id="_sequencer">
<title>Sequencer</title>
<simpara>The <emphasis role="strong">Sequencer</emphasis> state calls the same <emphasis>GroupSequenceCheck</emphasis> instance and method that the VM provision state machines run. The <emphasis>GroupSequenceCheck</emphasis> method checks the eligibility of the current service template provisioning task to run, according to the provision order defined when the resources were added to the service bundle. <emphasis>GroupSequenceCheck</emphasis> allows the state machine to continue if all other tasks with a lower provisioning priority have a <literal>state</literal> attribute of "finished". If any of the lower priority tasks are incomplete, <emphasis>GroupSequenceCheck</emphasis> exits with a state retry and a retry interval of one minute.</simpara>
<simpara>The common call to <emphasis>GroupSequenceCheck</emphasis> made by both VM provisioning and AnsibleTower job state machines allows us to interleave VM provisioning service items with Ansible configuration service items. We can be sure that the Ansible configuration will not proceed until the virtual machine has been fully provisioned.</simpara>
</section>
<section xml:id="_pre1_2">
<title>pre1</title>
<simpara>The <emphasis role="strong">pre1</emphasis> state calls calls the same <emphasis>CatalogItemInitialization</emphasis> instance and method that the VM provision state machines run. This is to ensure that any service dialog values passed into the service bundle are available to the Ansible service template provisioning task.</simpara>
</section>
</section>
</section>
<section xml:id="_service_models">
<title>Service Models</title>
<simpara>The Ansible-related service model that is of interest to us is the MiqAeServiceServiceAnsibleTower object.</simpara>
<section xml:id="_miqaeserviceserviceansibletower">
<title>MiqAeServiceServiceAnsibleTower</title>
<simpara>The MiqAeServiceServiceAnsibleTower object represents an Ansible Tower service. An object_walker printout of a typical object is as follows:</simpara>
<screen> --- attributes follow ---
 service.ancestry = nil
 service.created_at = 2016-12-01 11:11:00 UTC
 service.description = Install a Simple LAMP Stack
 service.display = true
 service.evm_owner_id = 1
 service.guid = d709ae06-b7b6-11e6-b465-001a4aa0151a
 service.id = 5
 service.miq_group_id = 2
 service.name = Simple LAMP Stack
 service.options[:dialog] = {"dialog_limit"=&gt;"lampsrv001", "dialog_param_ntpserver"=&gt;"192.168.xx.xx", "dialog_param_mysql_port"=&gt;"3306", "dialog_param_dbname"=&gt;"foodb", "dialog_param_dbuser"=&gt;"foouser", "dialog_param_dbpass"=&gt;"secret", "dialog_param_httpd_port"=&gt;"80", "dialog_param_repository"=&gt;"https://github.com/pemcg/mywebapp.git"}
 service.retired = nil
 service.retirement_last_warn = nil
 service.retirement_requester = nil
 service.retirement_state = nil
 service.retirement_warn = nil
 service.retires_on = nil
 service.service_template_id = 2
 service.tenant_id = 1
 service.type = ServiceAnsibleTower
 service.updated_at = 2016-12-01 11:11:00 UTC
 --- end of attributes ---
 --- virtual columns follow ---
 service.aggregate_all_vm_cpus = 0
 service.aggregate_all_vm_disk_count = 0
 service.aggregate_all_vm_disk_space_allocated = 0
 service.aggregate_all_vm_disk_space_used = 0
 service.aggregate_all_vm_memory = 0
 service.aggregate_all_vm_memory_on_disk = 0
 service.aggregate_direct_vm_cpus = 0
 service.aggregate_direct_vm_disk_count = 0
 service.aggregate_direct_vm_disk_space_allocated = 0
 service.aggregate_direct_vm_disk_space_used = 0
 service.aggregate_direct_vm_memory = 0
 service.aggregate_direct_vm_memory_on_disk = 0
 service.custom_1 = nil
 service.custom_2 = nil
 service.custom_3 = nil
 service.custom_4 = nil
 service.custom_5 = nil
 service.custom_6 = nil
 service.custom_7 = nil
 service.custom_8 = nil
 service.custom_9 = nil
 service.evm_owner_email = nil
 service.evm_owner_name = Administrator
 service.evm_owner_userid = admin
 service.has_parent = false
 service.owned_by_current_ldap_group = nil
 service.owned_by_current_user = nil
 service.owning_ldap_group = EvmGroup-super_administrator
 service.power_state = nil
 service.power_status = nil
 service.region_description = Region 0
 service.region_number = 0
 service.service_id = nil
 service.v_total_vms = 0
 --- end of virtual columns ---
 --- associations follow ---
 service.all_service_children
 service.direct_service_children
 service.direct_vms
 service.indirect_service_children
 service.indirect_vms
 service.parent_service
 service.root_service
 service.service_resources
 service.service_template
 service.tenant
 service.vms
 --- end of associations ---
 --- methods follow ---
 service.automate_retirement_entrypoint
 service.configuration_manager
 service.custom_get
 service.custom_keys
 service.custom_set
 service.description=
 service.dialog_options
 service.display=
 service.error_retiring?
 service.extend_retires_on
 service.finish_retirement
 service.get_dialog_option
 service.group=
 service.inspect
 service.inspect_all
 service.job
 service.job_options
 service.job_options=
 service.job_template
 service.job_template=
 service.launch_job
 service.model_suffix
 service.name=
 service.owner=
 service.parent_service=
 service.reload
 service.remove_from_vmdb
 service.retire_now
 service.retire_service_resources
 service.retired?
 service.retirement_state=
 service.retirement_warn=
 service.retires_on=
 service.retiring?
 service.set_dialog_option
 service.shutdown_guest
 service.start
 service.start_retirement
 service.stop
 service.suspend
 service.tag_assign
 service.tag_unassign
 service.tagged_with?
 service.tags
 --- end of methods ---</screen>
<simpara>The object is an extension of the standard MiqAeServiceService object type, but adds several useful Ansible-specific methods, as follows:</simpara>
<screen> service.configuration_manager
 service.job
 service.job_options
 service.job_options=
 service.job_template
 service.job_template=
 service.launch_job</screen>
<simpara>It is the <literal>launch_job</literal> method that is called during the state machine <emphasis role="strong">provision</emphasis> state to initiate the running of the Ansible Tower job.</simpara>
</section>
</section>
<section xml:id="_summary">
<title>Summary</title>
<simpara>The chapter has completed our examination of the Tower-related components in the Automate datastore that we started in <link xl:href="../tower_related_automate_components/chapter.asciidoc">Tower Related Automate Components</link>. The state machines, instances and methods that we&#8217;ve studied here are used when we create services to deploy Ansible configuration scripts.</simpara>
<simpara>In the next chapter we&#8217;ll run through two examples of creating Ansible Tower services; one for a single catalog item, and another as part of a catalog bundle.</simpara>
</section>
</section>
</article>